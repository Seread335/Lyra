// ============================================================================
// BYTECODE COMPILER OPTIMIZER - FIXED & VALIDATED
// ============================================================================
// Proper bounds checking, safe jump validation, dead code elimination

// ============================================================================
// DEAD CODE ELIMINATION WITH REACHABILITY ANALYSIS
// ============================================================================

// Remove unreachable bytecode instructions
proc removeDeadCode(bytecode_in: [i32], bytecode_len: i32) -> [i32] {
    var reachable: [bool]
    var i = 0
    
    // Initialize reachability array
    i = 0
    while i < bytecode_len {
        insert(reachable, false)
        i = i + 1
    }
    
    // Mark reachable code with control flow analysis
    i = 0
    if bytecode_len > 0 {
        reachable[0] = true
    }
    
    while i < bytecode_len {
        if i >= length(reachable) break
        
        if reachable[i] {
            // Bounds check before accessing bytecode (CRITICAL FIX)
            if i >= length(bytecode_in) break
            
            var opcode = bytecode_in[i]
            
            if opcode == OP_JMP {
                // JMP target is reachable - WITH BOUNDS CHECK (CRITICAL FIX)
                if i + 1 < bytecode_len && i + 1 < length(bytecode_in) {
                    var target = bytecode_in[i + 1]
                    if target >= 0 && target < bytecode_len {
                        reachable[target] = true
                    } else {
                        // Invalid jump target - don't mark reachable
                        setErrorQuick(ERR_COMP_JUMP_TARGET_INVALID,
                                     "Dead code: invalid jump target " + tostring(target))
                    }
                }
            }
            else if opcode == OP_JMP_IF_FALSE {
                // Both fall-through and jump paths are reachable - WITH BOUNDS CHECK (CRITICAL FIX)
                if i + 1 < bytecode_len && i + 1 < length(bytecode_in) {
                    var target = bytecode_in[i + 1]
                    if target >= 0 && target < bytecode_len {
                        reachable[target] = true
                    }
                    // Fall through is also reachable
                    if i + 2 < bytecode_len {
                        reachable[i + 2] = true
                    }
                }
            }
            else if opcode == OP_JMP_IF_TRUE {
                // CRITICAL FIX: Handle JMP_IF_TRUE (was missing!)
                if i + 1 < bytecode_len && i + 1 < length(bytecode_in) {
                    var target = bytecode_in[i + 1]
                    if target >= 0 && target < bytecode_len {
                        reachable[target] = true
                    }
                    // Fall through is also reachable
                    if i + 2 < bytecode_len {
                        reachable[i + 2] = true
                    }
                }
            }
            else if opcode != OP_RET && opcode != OP_HALT {
                // Next instruction is reachable
                if i + 1 < bytecode_len {
                    reachable[i + 1] = true
                }
            }
            // else: RET and HALT don't fall through
        }
        
        i = i + 1
    }
    
    // Build optimized bytecode with only reachable instructions
    var optimized: [i32]
    i = 0
    while i < bytecode_len {
        if i >= length(reachable) break
        
        if reachable[i] {
            if i < length(bytecode_in) {
                insert(optimized, bytecode_in[i])
            }
        }
        
        i = i + 1
    }
    
    return optimized
}

// ============================================================================
// CONSTANT POOL DEDUPLICATION
// ============================================================================

// Reduce constant pool by removing duplicates (CRITICAL FIX: O(n²) complexity + bounds)
proc deduplicateConstants(constants_in: [str]) -> [str] {
    var unique: [str]
    var i = 0
    
    while i < length(constants_in) {
        var const_val = constants_in[i]
        var found = false
        var j = 0
        
        // Check if constant already in unique list
        while j < length(unique) {
            if unique[j] == const_val {
                found = true
                break  // CRITICAL FIX: Early exit to improve O(n²) performance
            }
            j = j + 1
        }
        
        // Add only if not found
        if !found {
            insert(unique, const_val)
        }
        
        i = i + 1
    }
    
    return unique
}

// ============================================================================
// CONSTANT FOLDING AT COMPILE TIME
// ============================================================================

// Fold constant expressions (CRITICAL FIX: correct loop bounds)
proc foldConstantExpressions(operations: [str]) -> [str] {
    var result: [str]
    var i = 0
    
    while i < length(operations) {
        // CRITICAL FIX: Check if we have 3 elements for folding
        if i + 2 < length(operations) {
            var op1 = operations[i]
            var op2 = operations[i + 1]
            var op3 = operations[i + 2]
            
            // Check if all three operations match folding pattern
            if startsWith(op1, "CONST:") && startsWith(op2, "CONST:") {
                var folding_done = false
                
                // Extract values
                var val1_str = substring(op1, 6, length(op1))
                var val2_str = substring(op2, 6, length(op2))
                var val1 = toint(val1_str)
                var val2 = toint(val2_str)
                
                // Try folding based on operation
                if op3 == "ADD" {
                    var folded = tostring(val1 + val2)
                    insert(result, "CONST:" + folded)
                    folding_done = true
                    i = i + 3
                }
                else if op3 == "SUB" {
                    var folded = tostring(val1 - val2)
                    insert(result, "CONST:" + folded)
                    folding_done = true
                    i = i + 3
                }
                else if op3 == "MUL" {
                    var folded = tostring(val1 * val2)
                    insert(result, "CONST:" + folded)
                    folding_done = true
                    i = i + 3
                }
                else if op3 == "DIV" {
                    if val2 != 0 {
                        var folded = tostring(val1 / val2)
                        insert(result, "CONST:" + folded)
                        folding_done = true
                        i = i + 3
                    }
                }
                
                if !folding_done {
                    // Folding didn't happen
                    insert(result, op1)
                    i = i + 1
                }
            } else {
                insert(result, operations[i])
                i = i + 1
            }
        } else {
            // Less than 3 elements left, just copy
            insert(result, operations[i])
            i = i + 1
        }
    }
    
    return result
}

// ============================================================================
// JUMP OPTIMIZATION (JUMP CHAIN REDUCTION)
// ============================================================================

// Optimize jump targets (reduce jump chains with bounds checking and logging)
proc optimizeJumps(bytecode_in: [i32]) -> [i32] {
    var optimized = bytecode_in
    var changed = true
    var iterations = 0
    var max_iterations = 10
    
    while changed && iterations < max_iterations {
        changed = false
        iterations = iterations + 1
        var i = 0
        
        while i < length(optimized) {
            // Bounds check (CRITICAL FIX)
            if i + 1 >= length(optimized) break
            
            var opcode = optimized[i]
            
            // Check if this is a jump (CRITICAL FIX - bounds check)
            if opcode == OP_JMP || opcode == OP_JMP_IF_FALSE {
                if i + 1 < length(optimized) {
                    var target = optimized[i + 1]
                    
                    // Validate target (CRITICAL FIX)
                    if target < 0 || target >= length(optimized) {
                        setErrorQuick(ERR_COMP_JUMP_TARGET_INVALID,
                                     "Invalid jump target: " + tostring(target))
                        i = i + 1
                        continue
                    }
                    
                    // Check if target is also a jump - can chain
                    if target + 1 < length(optimized) && 
                       (optimized[target] == OP_JMP) {
                        // Skip to final target
                        if target + 1 < length(optimized) {
                            var final_target = optimized[target + 1]
                            
                            // Validate final target (CRITICAL FIX)
                            if final_target >= 0 && final_target < length(optimized) {
                                optimized[i + 1] = final_target
                                changed = true
                            }
                        }
                    }
                }
            }
            
            i = i + 1
        }
    }
    
    // CRITICAL FIX: Log warning if max iterations reached
    if iterations >= max_iterations {
        print("WARNING: optimizeJumps max_iterations (" + tostring(max_iterations) + ") reached - incomplete optimization possible")
    }
    
    return optimized
}

// ============================================================================
// LOOP DETECTION
// ============================================================================

// Detect loops in bytecode (backward jumps)
proc detectLoops(bytecode_in: [i32]) -> [i32] {
    var loops: [i32]
    var i = 0
    
    while i < length(bytecode_in) {
        // Bounds check (CRITICAL FIX)
        if i + 1 >= length(bytecode_in) break
        
        var opcode = bytecode_in[i]
        
        if opcode == OP_JMP || opcode == OP_JMP_IF_FALSE {
            var target = bytecode_in[i + 1]
            
            // Validate target (CRITICAL FIX)
            if target >= 0 && target < length(bytecode_in) {
                if target < i {  // Backward jump = loop
                    insert(loops, i)
                }
            }
        }
        
        i = i + 1
    }
    
    return loops
}

// ============================================================================
// COMPILATION STATISTICS
// ============================================================================

var comp_original_size: i32 = 0
var comp_optimized_size: i32 = 0
var comp_const_folds: i32 = 0
var comp_dead_code_removed: i32 = 0
var comp_jumps_optimized: i32 = 0
var comp_const_pool_original: i32 = 0
var comp_const_pool_optimized: i32 = 0

// Record compilation statistics
proc recordCompilationStats(original: i32, optimized: i32) {
    comp_original_size = original
    comp_optimized_size = optimized
}

// Record constant folding
proc recordConstantFold() {
    comp_const_folds = comp_const_folds + 1
}

// Record dead code removal
proc recordDeadCodeRemoval(count: i32) {
    comp_dead_code_removed = comp_dead_code_removed + count
}

// Record jump optimization
proc recordJumpOptimization() {
    comp_jumps_optimized = comp_jumps_optimized + 1
}

// ============================================================================
// COMPILER OPTIMIZATION PIPELINE
// ============================================================================

// Complete optimization pass (CRITICAL FIX - proper orchestration & validation)
proc runCompilerOptimization(bytecode_in: [i32], constants_in: [str]) -> [i32] {
    if length(bytecode_in) == 0 {
        return bytecode_in
    }
    
    // CRITICAL FIX: Validate inputs
    if length(bytecode_in) > 1000000 {
        setErrorQuick(ERR_COMP_INVALID_BYTECODE, "Bytecode too large")
        return bytecode_in
    }
    
    var bytecode = bytecode_in
    var bytecode_len = length(bytecode)
    
    print("=== COMPILER OPTIMIZATION STARTED ===")
    print("Original bytecode size: " + tostring(bytecode_len))
    
    // Step 1: Remove dead code (CRITICAL FIX)
    var before_dead = length(bytecode)
    bytecode = removeDeadCode(bytecode, bytecode_len)
    var after_dead = length(bytecode)
    
    if after_dead < before_dead {
        recordDeadCodeRemoval(before_dead - after_dead)
        print("Dead code removed: " + tostring(before_dead - after_dead) + " instructions")
    }
    
    // Step 2: Optimize jumps (CRITICAL FIX)
    var before_jumps = length(bytecode)
    bytecode = optimizeJumps(bytecode)
    var after_jumps = length(bytecode)
    
    if after_jumps < before_jumps {
        recordJumpOptimization()
        print("Jump chains optimized")
    }
    
    // Step 3: Detect loops for future optimization
    var loops = detectLoops(bytecode)
    print("Detected " + tostring(length(loops)) + " potential loops")
    
    // Step 4: Validate final bytecode (CRITICAL FIX)
    if !validateBytecode(bytecode) {
        print("WARNING: Optimized bytecode validation failed")
    }
    
    // Record final stats
    recordCompilationStats(bytecode_len, length(bytecode))
    
    print("=== COMPILER OPTIMIZATION COMPLETE ===")
    print("Final bytecode size: " + tostring(length(bytecode)))
    
    if bytecode_len > 0 {
        var reduction = (bytecode_len - length(bytecode)) * 100 / bytecode_len
        print("Size reduction: " + tostring(reduction) + "%")
    }
    
    return bytecode
}

// ============================================================================
// BYTECODE VALIDATION
// ============================================================================

// Validate bytecode integrity
proc validateBytecode(bytecode_in: [i32]) -> bool {
    var i = 0
    
    while i < length(bytecode_in) {
        var opcode = bytecode_in[i]
        
        // Validate opcode range
        if opcode < OP_HALT || opcode > OP_RET {
            setErrorQuick(ERR_COMP_INVALID_BYTECODE,
                         "Invalid opcode at position " + tostring(i) + ": " + tostring(opcode))
            return false
        }
        
        // Check instructions with operands have proper bounds (CRITICAL FIX)
        if opcode == OP_LOAD_CONST || opcode == OP_LOAD_VAR || 
           opcode == OP_STORE_VAR || opcode == OP_JMP || opcode == OP_JMP_IF_FALSE {
            if i + 1 >= length(bytecode_in) {
                setErrorQuick(ERR_COMP_INVALID_BYTECODE,
                             "Instruction at " + tostring(i) + " missing operand")
                return false
            }
        }
        
        i = i + 1
    }
    
    return true
}

// ============================================================================
// DIAGNOSTICS
// ============================================================================

// Dump compilation statistics
proc dumpCompilationStats() {
    print("=== COMPILATION STATISTICS ===")
    print("Original Size:      " + tostring(comp_original_size) + " bytes")
    print("Optimized Size:     " + tostring(comp_optimized_size) + " bytes")
    
    if comp_original_size > 0 {
        var reduction = (comp_original_size - comp_optimized_size) * 100 / comp_original_size
        print("Size Reduction:     " + tostring(reduction) + "%")
    }
    
    print("Constant Folds:     " + tostring(comp_const_folds))
    print("Dead Code Removed:  " + tostring(comp_dead_code_removed) + " instructions")
    print("Jumps Optimized:    " + tostring(comp_jumps_optimized))
}

// ============================================================================
// INITIALIZATION
// ============================================================================

proc initCompilerOptimizer() {
    comp_original_size = 0
    comp_optimized_size = 0
    comp_const_folds = 0
    comp_dead_code_removed = 0
    comp_jumps_optimized = 0
    print("COMPILER OPTIMIZER INITIALIZED")
}
