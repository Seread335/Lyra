// Performance Testing & Benchmarking Suite for Lyra
// ==================================================
// Micro benchmarks, profiling, regression detection

// Benchmark results
var bench_results: [str]
var bench_names: [str]
var bench_times: [i32]
var bench_count: i32 = 0

// Baseline performance for regression detection
var baseline_times: [i32]
var baseline_count: i32 = 0

// Simple timer (implementation-dependent)
var timer_start: i32 = 0
var timer_end: i32 = 0

proc startTimer() {
    timer_start = 0  // Would use system time in real implementation
}

proc stopTimer() -> i32 {
    timer_end = 0  // Would use system time in real implementation
    return timer_end - timer_start
}

// Microbenchmark: arithmetic operations
proc benchmarkArithmetic() -> i32 {
    startTimer()
    
    var result = 0
    var i = 0
    while i < 100000 {
        result = result + i
        result = result - 1
        result = result * 2
        i = i + 1
    }
    
    return stopTimer()
}

// Microbenchmark: array operations
proc benchmarkArrayOps() -> i32 {
    var arr: [str]
    var i = 0
    
    // Fill array
    while i < 10000 {
        insert(arr, tostring(i))
        i = i + 1
    }
    
    startTimer()
    
    // Search operations
    i = 0
    while i < 100 {
        var j = 0
        while j < length(arr) {
            if arr[j] == tostring(5000) {
                break()
            }
            j = j + 1
        }
        i = i + 1
    }
    
    return stopTimer()
}

// Microbenchmark: string operations
proc benchmarkStringOps() -> i32 {
    var s = "The quick brown fox jumps over the lazy dog"
    
    startTimer()
    
    var i = 0
    while i < 10000 {
        var len = s.strlen()
        var substr = substring(s, 0, 5)
        i = i + 1
    }
    
    return stopTimer()
}

// Microbenchmark: function calls
proc benchmarkFunctionCalls() -> i32 {
    startTimer()
    
    var i = 0
    while i < 50000 {
        var result = fib(10)
        i = i + 1
    }
    
    return stopTimer()
}

// Helper: recursive fibonacci (intentionally slow)
proc fib(n: i32) -> i32 {
    if n <= 1 return n
    return fib(n - 1) + fib(n - 2)
}

// Register benchmark result
proc recordBenchmark(name: str, time_ms: i32) {
    insert(bench_names, name)
    insert(bench_times, time_ms)
    bench_count = bench_count + 1
}

// Run all benchmarks
proc runAllBenchmarks() {
    print("=== LYRA PERFORMANCE BENCHMARKS ===")
    print("")
    
    // Arithmetic benchmark
    print("Running arithmetic benchmark...")
    var arith_time = benchmarkArithmetic()
    recordBenchmark("Arithmetic", arith_time)
    print("  Result: " + tostring(arith_time) + "ms")
    
    // Array operations benchmark
    print("Running array operations benchmark...")
    var array_time = benchmarkArrayOps()
    recordBenchmark("Array Operations", array_time)
    print("  Result: " + tostring(array_time) + "ms")
    
    // String operations benchmark
    print("Running string operations benchmark...")
    var string_time = benchmarkStringOps()
    recordBenchmark("String Operations", string_time)
    print("  Result: " + tostring(string_time) + "ms")
    
    // Function calls benchmark
    print("Running function calls benchmark...")
    var func_time = benchmarkFunctionCalls()
    recordBenchmark("Function Calls", func_time)
    print("  Result: " + tostring(func_time) + "ms")
    
    print("")
}

// Generate benchmark report
proc generateBenchmarkReport() {
    print("=== BENCHMARK REPORT ===")
    print("")
    
    var i = 0
    var total_time = 0
    
    while i < bench_count {
        print(bench_names[i] + ": " + tostring(bench_times[i]) + "ms")
        total_time = total_time + bench_times[i]
        i = i + 1
    }
    
    print("")
    print("Total Time: " + tostring(total_time) + "ms")
    
    // Check for regressions
    checkRegressions()
}

// Store baseline for regression detection
proc setBaseline() {
    baseline_count = bench_count
    var i = 0
    while i < bench_count {
        insert(baseline_times, bench_times[i])
        i = i + 1
    }
    print("Baseline established with " + tostring(baseline_count) + " benchmarks")
}

// Check performance regressions
proc checkRegressions() {
    if baseline_count == 0 return
    
    print("")
    print("=== REGRESSION ANALYSIS ===")
    
    var i = 0
    var regressions = 0
    var improvements = 0
    
    while i < bench_count && i < baseline_count {
        var current = bench_times[i]
        var baseline = baseline_times[i]
        var change = current - baseline
        var pct_change = 0
        
        if baseline > 0 {
            pct_change = change * 100 / baseline
        }
        
        if change > 0 && pct_change > 10 {
            print("REGRESSION: " + bench_names[i] + " +" + tostring(pct_change) + "%")
            regressions = regressions + 1
        }
        else if change < 0 && pct_change < -10 {
            print("IMPROVEMENT: " + bench_names[i] + " " + tostring(pct_change) + "%")
            improvements = improvements + 1
        }
        
        i = i + 1
    }
    
    print("")
    print("Regressions: " + tostring(regressions))
    print("Improvements: " + tostring(improvements))
}

// Profile-guided optimization data
var profile_hot_functions: [str]
var profile_call_counts: [i32]

proc recordFunctionCall(func_name: str) {
    var found = false
    var i = 0
    
    while i < length(profile_hot_functions) {
        if profile_hot_functions[i] == func_name {
            profile_call_counts[i] = profile_call_counts[i] + 1
            found = true
            break()
        }
        i = i + 1
    }
    
    if !found {
        insert(profile_hot_functions, func_name)
        insert(profile_call_counts, 1)
    }
}

// Get hot functions for optimization
proc getHotFunctions() -> [str] {
    var hot: [str]
    var threshold = 100
    var i = 0
    
    while i < length(profile_hot_functions) {
        if profile_call_counts[i] > threshold {
            insert(hot, profile_hot_functions[i])
        }
        i = i + 1
    }
    
    return hot
}

// Generate profiling report
proc generateProfilingReport() {
    print("=== PROFILING REPORT ===")
    print("")
    print("Hot Functions (>100 calls):")
    
    var i = 0
    while i < length(profile_hot_functions) {
        if profile_call_counts[i] > 100 {
            print("  " + profile_hot_functions[i] + ": " + tostring(profile_call_counts[i]) + " calls")
        }
        i = i + 1
    }
}
