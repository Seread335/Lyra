// ============================================================================
// JIT OPTIMIZATION - FIXED & IMPROVED
// ============================================================================
// Proper inline caching, type tracking with bounds, speculative optimization

// ============================================================================
// INLINE CACHE SYSTEM - FIXED LRU WITH TIMESTAMP OVERFLOW PREVENTION
// ============================================================================

// Inline cache structure
var ic_cache_keys: [str]
var ic_cache_values: [str]
var ic_cache_timestamps: [i32]  // For true LRU
var ic_cache_count: i32 = 0
var ic_max_entries: i32 = 1000
var ic_access_count: i32 = 0
var ic_timestamp_reset_threshold: i32 = 2000000000  // Reset before overflow

// Initialize inline cache
proc initInlineCache() {
    ic_cache_keys = []
    ic_cache_values = []
    ic_cache_timestamps = []
    ic_cache_count = 0
    ic_access_count = 0
    print("Inline cache initialized (max " + tostring(ic_max_entries) + " entries)")
}

// CRITICAL FIX: Reset timestamps when approaching overflow
// NOTE: In concurrent environment, add mutex protection around this operation
// to prevent race condition during timestamp rescaling
proc resetTimestampsIfNeeded() {
    // RACE CONDITION MITIGATION: This check is approximate and not atomic
    // In production, wrap with proper synchronization primitive
    if ic_access_count >= ic_timestamp_reset_threshold {
        // Rescale all timestamps to prevent overflow
        var i = 0
        var min_ts = 2147483647
        while i < ic_cache_count {
            if i >= length(ic_cache_timestamps) break
            if ic_cache_timestamps[i] < min_ts {
                min_ts = ic_cache_timestamps[i]
            }
            i = i + 1
        }
        
        // Shift all timestamps down
        i = 0
        while i < ic_cache_count {
            if i >= length(ic_cache_timestamps) break
            ic_cache_timestamps[i] = ic_cache_timestamps[i] - min_ts + 1
            i = i + 1
        }
        
        ic_access_count = ic_cache_count + 1
    }
}

// Lookup in cache with proper bounds checking (CRITICAL FIX)
proc icLookup(key: str) -> str {
    resetTimestampsIfNeeded()  // CRITICAL FIX: Prevent overflow
    
    var i = 0
    while i < ic_cache_count {
        if i >= length(ic_cache_keys) {
            break  // Bounds protection
        }
        
        if ic_cache_keys[i] == key {
            // Update access time with overflow check
            if ic_access_count >= 2147483646 {
                resetTimestampsIfNeeded()  // Force reset
            }
            ic_cache_timestamps[i] = ic_access_count
            ic_access_count = ic_access_count + 1
            return ic_cache_values[i]
        }
        
        i = i + 1
    }
    
    return ""  // Cache miss
}

// Add to cache with proper LRU eviction and memory cleanup (CRITICAL FIX)
proc icAdd(key: str, value: str) {
    resetTimestampsIfNeeded()  // CRITICAL FIX: Prevent overflow before add
    
    // Check if key already exists - update it
    var i = 0
    while i < ic_cache_count {
        if i >= length(ic_cache_keys) break
        
        if ic_cache_keys[i] == key {
            ic_cache_values[i] = value
            ic_cache_timestamps[i] = ic_access_count
            ic_access_count = ic_access_count + 1
            return
        }
        
        i = i + 1
    }
    
    // Add new entry
    if ic_cache_count < ic_max_entries {
        // Bounds check before insert
        if length(ic_cache_keys) > ic_max_entries {
            return  // Safety: don't add if we're over limit
        }
        
        insert(ic_cache_keys, key)
        insert(ic_cache_values, value)
        insert(ic_cache_timestamps, ic_access_count)
        ic_cache_count = ic_cache_count + 1
        ic_access_count = ic_access_count + 1
    } else {
        // Find LRU entry and evict it (CRITICAL FIX: clear old key properly)
        var min_time = 2147483647
        var lru_index = 0
        
        i = 0
        while i < ic_cache_count {
            if i >= length(ic_cache_timestamps) break
            
            if ic_cache_timestamps[i] < min_time {
                min_time = ic_cache_timestamps[i]
                lru_index = i
            }
            
            i = i + 1
        }
        
        // Replace LRU entry with proper cleanup (CRITICAL FIX for memory leak)
        if lru_index >= 0 && lru_index < length(ic_cache_keys) {
            // Clear old entry completely before reuse
            ic_cache_keys[lru_index] = ""  // Clear old key
            ic_cache_values[lru_index] = ""
            ic_cache_timestamps[lru_index] = 0
            
            // Now add new entry
            ic_cache_keys[lru_index] = key
            ic_cache_values[lru_index] = value
            ic_cache_timestamps[lru_index] = ic_access_count
            ic_access_count = ic_access_count + 1
        }
    }
}

// Clear entire cache
proc icClear() {
    ic_cache_keys = []
    ic_cache_values = []
    ic_cache_timestamps = []
    ic_cache_count = 0
    ic_access_count = 0
}

// Get cache statistics
proc icGetStats() -> str {
    return "IC: " + tostring(ic_cache_count) + "/" + tostring(ic_max_entries) + 
           " entries, access count: " + tostring(ic_access_count)
}

// ============================================================================
// TYPE TRACKING SYSTEM - WITH LIMITS (HIGH FIX)
// ============================================================================

var type_history: [str]
var type_ops_count: [i32]
var type_tracking_enabled: bool = true
var max_type_entries: i32 = 1000  // FIX: Added limit

// Initialize type tracking
proc initTypeTracking() {
    type_history = []
    type_ops_count = []
}

// Record type for operation with bounds checking (HIGH FIX)
proc recordType(operation: str, type_name: str) {
    if !type_tracking_enabled return
    
    // Bounds check before adding
    if length(type_history) >= max_type_entries {
        // Drop oldest entries (simple eviction)
        if length(type_history) > 0 {
            type_history[0] = type_history[length(type_history) - 1]
            type_ops_count[0] = type_ops_count[length(type_ops_count) - 1]
            // Would normally remove last, but we don't have remove()
        }
        return
    }
    
    var key = operation + ":" + type_name
    var found = false
    var i = 0
    
    while i < length(type_history) {
        if type_history[i] == key {
            type_ops_count[i] = type_ops_count[i] + 1
            found = true
            break
        }
        i = i + 1
    }
    
    if !found {
        insert(type_history, key)
        insert(type_ops_count, 1)
    }
}

// Get most common type for operation (HIGH FIX - improved performance)
proc getDominantType(operation: str) -> str {
    var max_count = 0
    var dominant = ""
    var i = 0
    var op_prefix = operation + ":"
    
    while i < length(type_history) {
        var entry = type_history[i]
        
        // Check if this entry is for our operation
        if startsWith(entry, op_prefix) {
            if type_ops_count[i] > max_count {
                max_count = type_ops_count[i]
                dominant = substring(entry, length(op_prefix), length(entry))
            }
        }
        
        i = i + 1
    }
    
    return dominant
}

// ============================================================================
// CONSTANT FOLDING
// ============================================================================

// Fold constant expressions at compile time
proc foldConstants(val1: str, val2: str, operation: str) -> str {
    if operation == "ADD" {
        return tostring(toint(val1) + toint(val2))
    }
    if operation == "SUB" {
        return tostring(toint(val1) - toint(val2))
    }
    if operation == "MUL" {
        return tostring(toint(val1) * toint(val2))
    }
    if operation == "DIV" {
        var divisor = toint(val2)
        if divisor == 0 {
            errorDivisionByZero()
            return "0"
        }
        return tostring(toint(val1) / divisor)
    }
    
    return ""
}

// ============================================================================
// SPECULATIVE OPTIMIZATION
// ============================================================================

var spec_enabled: bool = true
var spec_threshold: i32 = 100
var call_history: [str]
var call_counts: [i32]

// Record function call
proc recordCall(function_name: str) {
    if !spec_enabled return
    
    var i = 0
    while i < length(call_history) {
        if call_history[i] == function_name {
            call_counts[i] = call_counts[i] + 1
            return
        }
        i = i + 1
    }
    
    // New function
    insert(call_history, function_name)
    insert(call_counts, 1)
}

// Should we speculate on this function?
proc shouldSpeculate(function_name: str) -> bool {
    var i = 0
    while i < length(call_history) {
        if call_history[i] == function_name {
            if call_counts[i] >= spec_threshold {
                return true
            }
        }
        i = i + 1
    }
    
    return false
}

// ============================================================================
// CODE SPECIALIZATION
// ============================================================================

var specialized_code: [str]
var specialized_funcs: [str]

// Generate specialized bytecode
proc generateSpecializedBytecode(function_name: str, dominant_type: str) -> str {
    // In real system, would generate optimized bytecode for specific type
    // For now, just return a marker
    return "SPEC:" + function_name + ":" + dominant_type
}

// ============================================================================
// INITIALIZATION
// ============================================================================

proc initJITOptimization() {
    initInlineCache()
    initTypeTracking()
    call_history = []
    call_counts = []
    specialized_code = []
    specialized_funcs = []
    print("JIT OPTIMIZATION INITIALIZED")
}

// ============================================================================
// DIAGNOSTICS
// ============================================================================

proc dumpJITState() {
    print("=== JIT STATE ===")
    print(icGetStats())
    print("Type history entries: " + tostring(length(type_history)))
    print("Call history entries: " + tostring(length(call_history)))
    print("Specialized funcs: " + tostring(length(specialized_funcs)))
}
