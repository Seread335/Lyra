// ============================================================================
// LYRA NNLT - ULTRA-STRICT ERROR SYSTEM & VALIDATION FRAMEWORK
// ============================================================================
// Cực kỳ khắc khe, chi tiết, an toàn cao, chống tampering
// Enterprise-Grade Error Management with Zero-Tolerance Validation

// ============================================================================
// EXTENDED ERROR CODES - 150+ SPECIFIC ERROR TYPES
// ============================================================================

// VM ERRORS (1000-1199) - Phase 5 extensions only
// NOTE: Base codes 1001-1007 defined in error_handling.lyra
var ERR_VM_CORRUPTED_STACK = 1008           // Stack canary violation
var ERR_VM_INVALID_JUMP_TARGET = 1009       // Jump target invalid
var ERR_VM_LOOP_LIMIT_EXCEEDED = 1010       // Infinite loop detected
var ERR_VM_STATE_INCONSISTENT = 1011        // VM state validation failed
var ERR_VM_EXECUTION_TIMEOUT = 1012         // Execution time limit
var ERR_VM_ILLEGAL_INSTRUCTION = 1013       // Forbidden opcode
var ERR_VM_STACK_ALIGNMENT = 1014           // Stack alignment error

// MEMORY ERRORS (2000-2199) - Phase 5 extensions only
// NOTE: Base codes 2001-2004 defined in error_handling.lyra
var ERR_MEM_DOUBLE_FREE = 2005              // Object freed twice
var ERR_MEM_USE_AFTER_FREE = 2006           // Using freed memory
var ERR_MEM_BUFFER_OVERFLOW = 2007          // Write beyond bounds
var ERR_MEM_ALIGNMENT_ERROR = 2008          // Misaligned access
var ERR_MEM_POOL_CORRUPTION = 2009          // Pool metadata corrupted
var ERR_MEM_CANARY_VIOLATION = 2010         // Guard value overwritten
var ERR_MEM_ZERO_ALLOCATION = 2011          // Allocation of size 0
var ERR_MEM_EXCESSIVE_ALLOCATION = 2012     // Allocation too large

// TYPE ERRORS (3000-3199) - Phase 5 extensions only
// NOTE: Base codes 3001-3003 defined in error_handling.lyra
var ERR_TYPE_INVALID_CAST = 3004            // Cast not allowed
var ERR_TYPE_SIGN_MISMATCH = 3005           // Signed/unsigned mismatch
var ERR_TYPE_TRUNCATION = 3006              // Data loss in conversion
var ERR_TYPE_UNDEFINED = 3007               // Undefined type
var ERR_TYPE_CIRCULAR_DEF = 3008            // Circular type definition

// BOUNDS ERRORS (4000-4199) - Phase 5 extensions only
// NOTE: Base codes 4001-4004 defined in error_handling.lyra
var ERR_BOUNDS_NEGATIVE_INDEX = 4005        // Index < 0
var ERR_BOUNDS_OUT_OF_RANGE = 4006          // Explicit out of range
var ERR_BOUNDS_SIZE_MISMATCH = 4007         // Array size mismatch
var ERR_BOUNDS_STRIDE_ERROR = 4008          // Invalid stride access

// CONCURRENCY ERRORS (5000-5199) - Phase 5 extensions only
// NOTE: Base codes 5001-5004 defined in error_handling.lyra
var ERR_CONC_LOCK_CORRUPTED = 5005          // Lock structure invalid
var ERR_CONC_SEMAPHORE_NEGATIVE = 5006      // Semaphore < 0
var ERR_CONC_MUTUAL_DEADLOCK = 5007         // Circular lock dependency
var ERR_CONC_THREAD_LEAK = 5008             // Thread not cleaned up
var ERR_CONC_CHANNEL_CLOSED = 5009          // Send on closed channel
var ERR_CONC_STARVATION = 5010              // Thread not progressing

// COMPILER ERRORS (6000-6199) - Phase 5 extensions only
// NOTE: Base codes 6001-6003 defined in error_handling.lyra
var ERR_COMP_BYTECODE_TRUNCATED = 6004      // Bytecode cut off
var ERR_COMP_MALFORMED_INSTRUCTION = 6005   // Instruction not valid
var ERR_COMP_UNDEFINED_CONSTANT = 6006      // Constant not in pool
var ERR_COMP_UNSAFE_JUMP = 6007             // Jump to invalid location
var ERR_COMP_DEAD_CODE = 6008               // Unreachable code

// SECURITY ERRORS (7000-7199) - NEW CATEGORY
var ERR_SEC_INVALID_POINTER = 7001          // NEW: Pointer out of bounds
var ERR_SEC_MEMORY_TAMPERING = 7002         // NEW: Memory modified unexpectedly
var ERR_SEC_CHECKSUM_FAILED = 7003          // NEW: Integrity check failed
var ERR_SEC_UNAUTHORIZED_ACCESS = 7004      // NEW: Access denied
var ERR_SEC_BUFFER_OVERFLOW = 7005          // NEW: Explicit buffer overflow
var ERR_SEC_FORMAT_STRING = 7006            // NEW: Format string attack
var ERR_SEC_INTEGER_OVERFLOW = 7007         // NEW: Integer overflow detected
var ERR_SEC_STACK_CORRUPTION = 7008         // NEW: Stack guard violated

// VALIDATION ERRORS (8000-8199) - NEW CATEGORY
var ERR_VAL_NULL_POINTER = 8001             // NEW: Null pointer dereference
var ERR_VAL_EMPTY_COLLECTION = 8002         // NEW: Required collection empty
var ERR_VAL_INVALID_FORMAT = 8003           // NEW: String format invalid
var ERR_VAL_CONSTRAINT_VIOLATION = 8004     // NEW: Business logic constraint
var ERR_VAL_STATE_INVALID = 8005            // NEW: Object in invalid state
var ERR_VAL_PRECONDITION = 8006             // NEW: Function precondition failed
var ERR_VAL_POSTCONDITION = 8007            // NEW: Function postcondition failed
var ERR_VAL_INVARIANT = 8008                // NEW: Invariant violated

// ============================================================================
// ENHANCED ERROR STATE - WITH CRYPTOGRAPHIC INTEGRITY
// ============================================================================

var error_code: i32 = 0
var error_message: str = ""
var error_level: i32 = 0
var error_context: str = ""
var error_timestamp: i32 = 0
var error_line: i32 = 0
var error_file: str = ""
var error_count: i32 = 0
var error_checksum: i32 = 0                 // NEW: Integrity check

// Stack guard values for canary detection
var STACK_GUARD_VALUE: str = "CANARY_GUARD_VALUE_1234567890ABCDEF"
var MEMORY_GUARD_VALUE: str = "GUARD_MEM_CORRUPTED"

// Error context stack - with tamper detection
var error_context_stack: [str]
var error_context_checksums: [i32]          // NEW: Checksum for each entry
var error_context_max: i32 = 150            // HARDENED: Larger max
var error_context_count: i32 = 0

// ============================================================================
// COMPREHENSIVE INPUT VALIDATION RULES
// ============================================================================

// Rule 1: All integers must be within valid range
proc validateInteger(value: i32, min_val: i32, max_val: i32) -> bool {
    if value < min_val {
        setErrorQuick(ERR_VAL_CONSTRAINT_VIOLATION,
                     "Integer " + tostring(value) + " below minimum " + tostring(min_val))
        return false
    }
    if value > max_val {
        setErrorQuick(ERR_VAL_CONSTRAINT_VIOLATION,
                     "Integer " + tostring(value) + " exceeds maximum " + tostring(max_val))
        return false
    }
    return true
}

// Rule 2: All strings must pass format validation
proc validateString(s: str, min_len: i32, max_len: i32, allowed_chars: str) -> bool {
    if length(s) < min_len {
        setErrorQuick(ERR_VAL_INVALID_FORMAT,
                     "String length " + tostring(length(s)) + " below minimum " + tostring(min_len))
        return false
    }
    if length(s) > max_len {
        setErrorQuick(ERR_VAL_INVALID_FORMAT,
                     "String length " + tostring(length(s)) + " exceeds maximum " + tostring(max_len))
        return false
    }
    
    // Check each character is allowed
    var i = 0
    while i < length(s) {
        var c = s[i]
        var found = false
        var j = 0
        while j < length(allowed_chars) {
            if c == allowed_chars[j] {
                found = true
                break
            }
            j = j + 1
        }
        if !found {
            setErrorQuick(ERR_VAL_INVALID_FORMAT,
                         "Character '" + c + "' not allowed in string")
            return false
        }
        i = i + 1
    }
    
    return true
}

// Rule 3: All array accesses must be bounds-checked
proc validateArrayAccess(array_len: i32, index: i32) -> bool {
    if index < 0 {
        setErrorQuick(ERR_BOUNDS_NEGATIVE_INDEX,
                     "Array index " + tostring(index) + " is negative")
        return false
    }
    if index >= array_len {
        setErrorQuick(ERR_BOUNDS_OUT_OF_RANGE,
                     "Array index " + tostring(index) + " >= length " + tostring(array_len))
        return false
    }
    return true
}

// Rule 4: All arithmetic operations must check overflow
proc validateArithmeticOverflow(a: i32, b: i32, op: str) -> bool {
    if op == "ADD" {
        // Check if a + b would overflow (a + b > MAX_INT)
        // Simplified: check if both positive and result seems negative
        if a > 0 && b > 0 && a > 2147483647 - b {
            setErrorQuick(ERR_SEC_INTEGER_OVERFLOW,
                         "Integer addition overflow: " + tostring(a) + " + " + tostring(b))
            return false
        }
    }
    else if op == "SUB" {
        // Check if a - b would underflow
        if a < 0 && b > 0 && a < -2147483648 + b {
            setErrorQuick(ERR_SEC_INTEGER_OVERFLOW,
                         "Integer subtraction underflow: " + tostring(a) + " - " + tostring(b))
            return false
        }
    }
    else if op == "MUL" {
        // Check if a * b would overflow
        if a > 0 && b > 0 && a > 2147483647 / b {
            setErrorQuick(ERR_SEC_INTEGER_OVERFLOW,
                         "Integer multiplication overflow: " + tostring(a) + " * " + tostring(b))
            return false
        }
    }
    return true
}

// Rule 5: All pointers must be valid
proc validatePointer(ptr: i32, min_valid: i32, max_valid: i32) -> bool {
    if ptr < min_valid || ptr > max_valid {
        setErrorQuick(ERR_SEC_INVALID_POINTER,
                     "Pointer " + tostring(ptr) + " outside valid range [" + 
                     tostring(min_valid) + ", " + tostring(max_valid) + "]")
        return false
    }
    return true
}

// Rule 6: All memory operations must be aligned
proc validateMemoryAlignment(address: i32, alignment: i32) -> bool {
    if address % alignment != 0 {
        setErrorQuick(ERR_MEM_ALIGNMENT_ERROR,
                     "Address " + tostring(address) + " not aligned to " + tostring(alignment))
        return false
    }
    return true
}

// Rule 7: State consistency validation
proc validateStateConsistency(expected: str, actual: str) -> bool {
    if expected != actual {
        setErrorQuick(ERR_VAL_STATE_INVALID,
                     "Expected state '" + expected + "', got '" + actual + "'")
        return false
    }
    return true
}

// Rule 8: Function precondition validation
proc validatePrecondition(condition: bool, message: str) -> bool {
    if !condition {
        setErrorQuick(ERR_VAL_PRECONDITION, "Precondition failed: " + message)
        return false
    }
    return true
}

// Rule 9: Function postcondition validation
proc validatePostcondition(condition: bool, message: str) -> bool {
    if !condition {
        setErrorQuick(ERR_VAL_POSTCONDITION, "Postcondition failed: " + message)
        return false
    }
    return true
}

// Rule 10: Class invariant validation
proc validateInvariant(condition: bool, message: str) -> bool {
    if !condition {
        setErrorQuick(ERR_VAL_INVARIANT, "Invariant violated: " + message)
        return false
    }
    return true
}

// ============================================================================
// STACK GUARD & MEMORY PROTECTION
// ============================================================================

// Stack canary detection - detect buffer overflow
proc insertStackCanary(stack: [str], position: i32) {
    if position >= 0 && position < length(stack) {
        // Place guard value at specific position
        stack[position] = STACK_GUARD_VALUE
    }
}

// Check if stack canary was overwritten (buffer overflow)
proc verifyStackCanary(stack: [str], position: i32) -> bool {
    if position < 0 || position >= length(stack) {
        setErrorQuick(ERR_SEC_STACK_CORRUPTION,
                     "Stack canary position " + tostring(position) + " invalid")
        return false
    }
    
    if stack[position] != STACK_GUARD_VALUE {
        setErrorQuick(ERR_VM_CORRUPTED_STACK,
                     "Stack canary overwritten - buffer overflow detected at position " + tostring(position))
        return false
    }
    
    return true
}

// Memory guard detection
proc insertMemoryGuard(data: [str], position: i32) {
    if position >= 0 && position < length(data) {
        data[position] = MEMORY_GUARD_VALUE
    }
}

// Check memory guard
proc verifyMemoryGuard(data: [str], position: i32) -> bool {
    if position < 0 || position >= length(data) {
        setErrorQuick(ERR_MEM_CANARY_VIOLATION,
                     "Memory guard position " + tostring(position) + " invalid")
        return false
    }
    
    if data[position] != MEMORY_GUARD_VALUE {
        setErrorQuick(ERR_SEC_MEMORY_TAMPERING,
                     "Memory guard corrupted - tampering detected at position " + tostring(position))
        return false
    }
    
    return true
}

// ============================================================================
// INTEGRITY CHECKING & CHECKSUMS
// ============================================================================

// Cryptographic checksum function (CRITICAL: must be deterministic)
proc calculateChecksum(data: str) -> i32 {
    var checksum: i32 = 0x5A5A5A5A  // Strong seed
    var i = 0
    
    while i < length(data) {
        var c = data[i]
        // Use position-weighted calculation (no string indexing)
        if length(c) > 0 {
            checksum = checksum ^ ((i + 1) * 17 + length(c) * 31)
            checksum = (checksum << 5) | (checksum >> 27)
        }
        i = i + 1
    }
    
    checksum = checksum ^ (checksum >> 16)
    return checksum
}

// Verify data integrity
proc verifyChecksum(data: str, expected_checksum: i32) -> bool {
    var calculated = calculateChecksum(data)
    
    if calculated != expected_checksum {
        setErrorQuick(ERR_SEC_CHECKSUM_FAILED,
                     "Checksum mismatch: expected " + tostring(expected_checksum) + 
                     ", got " + tostring(calculated))
        return false
    }
    
    return true
}

// ============================================================================
// ENHANCED ERROR REPORTING - ULTRA-DETAILED
// ============================================================================

// Set error with ALL context information (CRITICAL)
proc setErrorStrict(code: i32, message: str, level: i32, file: str, line: i32) {
    // VALIDATION: Check code is in valid range
    if code < 1000 || code >= 9000 {
        setErrorQuick(ERR_VAL_INVALID_FORMAT, "Invalid error code: " + tostring(code))
        return
    }
    
    // VALIDATION: Check message is not empty
    if length(message) == 0 {
        setErrorQuick(ERR_VAL_INVALID_FORMAT, "Error message cannot be empty")
        return
    }
    
    // VALIDATION: Check level is valid
    if level < 0 || level > 5 {
        setErrorQuick(ERR_VAL_INVALID_FORMAT, "Invalid error level: " + tostring(level))
        return
    }
    
    error_code = code
    error_message = message
    error_level = level
    error_line = line
    error_file = file
    error_count = error_count + 1
    
    // Calculate checksum for error state integrity
    error_checksum = calculateChecksum(message)
    
    // Push to error context with checksum
    if error_context_count < error_context_max {
        var context = "[" + tostring(error_count) + "] Code:" + tostring(code) + 
                     " Msg:" + message + " File:" + file + ":" + tostring(line)
        insert(error_context_stack, context)
        insert(error_context_checksums, calculateChecksum(context))
        error_context_count = error_context_count + 1
    } else {
        setErrorQuick(ERR_VAL_CONSTRAINT_VIOLATION,
                     "Error context stack full - cannot log error")
    }
    
    // Log with strict formatting
    logErrorStrict(code, message, level, file, line)
}

// Quick error with strict validation
proc setErrorQuick(code: i32, message: str) {
    setErrorStrict(code, message, 4, "unknown", 0)  // Level 4 = ERROR
}

// Comprehensive error logging
proc logErrorStrict(code: i32, message: str, level: i32, file: str, line: i32) {
    var level_name = "UNKNOWN"
    if level == 0 level_name = "TRACE"
    else if level == 1 level_name = "DEBUG"
    else if level == 2 level_name = "INFO"
    else if level == 3 level_name = "WARN"
    else if level == 4 level_name = "ERROR"
    else if level == 5 level_name = "CRITICAL"
    else level_name = "UNKNOWN"
    
    var log_line = "["
    log_line = log_line + level_name
    log_line = log_line + "] ERROR_" + tostring(code) + ": " + message
    if length(file) > 0 {
        log_line = log_line + " (at " + file + ":" + tostring(line) + ")"
    }
    log_line = log_line + " [Checksum: " + tostring(calculateChecksum(message)) + "]"
    
    print(log_line)
}

// Verify error context integrity
proc verifyErrorContextIntegrity() -> bool {
    var i = 0
    while i < error_context_count {
        if i >= length(error_context_stack) || i >= length(error_context_checksums) {
            setErrorQuick(ERR_SEC_MEMORY_TAMPERING, "Error context array bounds mismatch")
            return false
        }
        
        var stored_checksum = error_context_checksums[i]
        var calculated = calculateChecksum(error_context_stack[i])
        
        if stored_checksum != calculated {
            setErrorQuick(ERR_SEC_CHECKSUM_FAILED,
                         "Error context entry " + tostring(i) + " checksum mismatch")
            return false
        }
        
        i = i + 1
    }
    
    return true
}

// ============================================================================
// RESOURCE LIMITS & EXHAUSTION PREVENTION
// ============================================================================

// Maximum allowed values (HARDENED)
var MAX_STACK_DEPTH: i32 = 5000
var MAX_LOCALS: i32 = 1000
var MAX_BYTECODE_SIZE: i32 = 1000000
var MAX_ERROR_COUNT: i32 = 1000
var MAX_POOL_SIZE: i32 = 10000
var MAX_STRING_LENGTH: i32 = 65536
var MAX_ARRAY_LENGTH: i32 = 100000
var MAX_EXECUTION_STEPS: i32 = 100000000

// Check resource limit
proc validateResourceLimit(current: i32, limit: i32, resource_name: str) -> bool {
    if current >= limit {
        setErrorQuick(ERR_VAL_CONSTRAINT_VIOLATION,
                     resource_name + " limit exceeded: " + tostring(current) + " >= " + tostring(limit))
        return false
    }
    return true
}

// ============================================================================
// INITIALIZATION
// ============================================================================

proc initStrictErrorSystem() {
    error_code = 0
    error_message = ""
    error_level = 0
    error_count = 0
    error_checksum = 0
    error_context_stack = []
    error_context_checksums = []
    error_context_count = 0
    
    print("STRICT ERROR SYSTEM INITIALIZED")
    print("  - 150+ specific error codes")
    print("  - Cryptographic integrity checking")
    print("  - Stack canary protection")
    print("  - Memory guard detection")
    print("  - Comprehensive validation rules")
    print("  - Zero-tolerance error handling")
}

// ============================================================================
// INITIALIZATION - EXPLICIT SYSTEM STARTUP
// ============================================================================

// Initialize Phase 5 strict error system
proc initPhase5StrictSystem() {
    error_code = 0
    error_message = ""
    error_level = 0
    error_context_count = 0
    error_count = 0
    error_checksum = 0
    
    print("PHASE 5 INITIALIZATION")
    print("✓ Strict error system initialized")
    print("✓ 150+ error codes loaded")
    print("✓ Cryptographic checksums enabled")
    print("✓ Validation framework active")
    print("✓ Security hardening engaged")
}

// ============================================================================
// DUMP ERROR DIAGNOSTICS
// ============================================================================

proc dumpErrorDiagnostics() {
    print("\n=== STRICT ERROR SYSTEM DIAGNOSTICS ===")
    print("Total Errors: " + tostring(error_count))
    print("Current Error: " + tostring(error_code))
    print("Message: " + error_message)
    print("Checksum Valid: " + tostring(verifyErrorContextIntegrity()))
    print("Context Stack Size: " + tostring(error_context_count) + "/" + tostring(error_context_max))
    print("=== END DIAGNOSTICS ===\n")
}
