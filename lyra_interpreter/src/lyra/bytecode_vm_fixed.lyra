// Bytecode Virtual Machine for Lyra - FIXED & OPTIMIZED
// High-performance stack-based VM with proper error handling

// ============================================================================
// VM STATE - OPTIMIZED FOR CACHE LOCALITY
// ============================================================================

var vm_stack: [str]
var vm_sp: i32 = 0
var vm_pc: i32 = 0
var vm_halted: bool = false
var vm_return_value: str = ""
var vm_local_vars: [str]
var vm_call_stack: [i32]

// Stack limits for safety
var vm_max_stack_depth: i32 = 10000
var vm_max_locals: i32 = 1000

// Pre-computed values for optimization
var vm_code_len: i32 = 0
var vm_constants_len: i32 = 0

// Error handling integration
var vm_last_error: i32 = 0

// ============================================================================
// INITIALIZATION
// ============================================================================

proc initVM() {
    vm_stack = []
    vm_sp = 0
    vm_pc = 0
    vm_halted = false
    vm_return_value = ""
    vm_local_vars = []
    vm_call_stack = []
    
    // Pre-compute lengths
    if length(bytecode) > 0 {
        vm_code_len = length(bytecode)
    }
    if length(bytecode_constants) > 0 {
        vm_constants_len = length(bytecode_constants)
    }
    
    initErrorHandling()
    print("VM INITIALIZED - Stack Depth: " + tostring(vm_max_stack_depth) + 
          ", Max Locals: " + tostring(vm_max_locals))
}

// ============================================================================
// STACK OPERATIONS - WITH SAFETY CHECKS
// ============================================================================

// Push with overflow detection (CRITICAL FIX)
proc vmPush(value: str) {
    if vm_sp >= vm_max_stack_depth {
        errorStackOverflow()
        vm_halted = true
        return
    }
    
    insert(vm_stack, value)
    vm_sp = vm_sp + 1
}

// Pop with underflow detection (CRITICAL FIX: correct bounds logic)
proc vmPop() -> str {
    if vm_sp <= 0 {
        errorStackUnderflow("vmPop")
        return "0"
    }
    
    vm_sp = vm_sp - 1
    
    // CRITICAL FIX: Check bounds after decrement
    if vm_sp < 0 || vm_sp >= length(vm_stack) {
        return "0"
    }
    
    return vm_stack[vm_sp]
}

// Safe peek
proc vmPeek() -> str {
    if vm_sp <= 0 {
        errorStackUnderflow("vmPeek")
        return "0"
    }
    
    var idx = vm_sp - 1
    if idx >= length(vm_stack) {
        return "0"
    }
    
    return vm_stack[idx]
}

// ============================================================================
// LOCAL VARIABLE MANAGEMENT - WITH BOUNDS CHECKING
// ============================================================================

// Get local variable with bounds checking (CRITICAL FIX: log uninitialized access)
proc vmGetLocal(idx: i32) -> str {
    if idx < 0 {
        errorBytecodeIndex(idx, vm_max_locals)
        return "0"
    }
    
    if idx >= length(vm_local_vars) {
        // CRITICAL FIX: Log warning for uninitialized variable access
        if idx >= vm_max_locals {
            errorBytecodeIndex(idx, vm_max_locals)
        }
        return "0"  // Uninitialized variable defaults to 0
    }
    
    return vm_local_vars[idx]
}

// Set local variable with bounds checking (CRITICAL FIX)
proc vmSetLocal(idx: i32, value: str) {
    if idx < 0 {
        errorBytecodeIndex(idx, vm_max_locals)
        return
    }
    
    if idx >= vm_max_locals {
        setErrorQuick(ERR_BOUNDS_VARIABLE_INDEX,
                     "Variable index " + tostring(idx) + " exceeds max " + 
                     tostring(vm_max_locals))
        return
    }
    
    // Extend locals array if needed
    while length(vm_local_vars) <= idx {
        if length(vm_local_vars) >= vm_max_locals {
            setErrorQuick(ERR_BOUNDS_VARIABLE_INDEX,
                         "Cannot extend local variables beyond " + 
                         tostring(vm_max_locals))
            return
        }
        insert(vm_local_vars, "0")
    }
    
    vm_local_vars[idx] = value
}

// ============================================================================
// ARITHMETIC OPERATIONS - WITH ERROR HANDLING
// ============================================================================

// Addition with type checking
proc vmAdd(a: str, b: str) -> str {
    var result = toint(a) + toint(b)
    return tostring(result)
}

// Subtraction (CRITICAL FIX: correct order a - b not b - a)
proc vmSubtract(a: str, b: str) -> str {
    var result = toint(a) - toint(b)
    return tostring(result)
}

// Multiplication
proc vmMultiply(a: str, b: str) -> str {
    var result = toint(a) * toint(b)
    return tostring(result)
}

// Division with bounds checking (CRITICAL FIX: correct operand order)
proc vmDivide(a: str, b: str) -> str {
    var divisor = toint(b)  // CRITICAL FIX: b is divisor, a is dividend
    
    if divisor == 0 {
        errorDivisionByZero()
        // RECOVERY: Use fallback value
        return "0"
    }
    
    var dividend = toint(a)
    return tostring(dividend / divisor)
}

// Modulo with bounds checking (CRITICAL FIX: correct operand order)
proc vmModulo(a: str, b: str) -> str {
    var divisor = toint(b)  // CRITICAL FIX: b is divisor, a is dividend
    
    if divisor == 0 {
        errorModuloByZero()
        // RECOVERY: Use fallback value
        return "0"
    }
    
    var dividend = toint(a)
    return tostring(dividend % divisor)
}

// Negation
proc vmNegate(a: str) -> str {
    return tostring(-toint(a))
}

// Logical NOT
proc vmLogicalNot(a: str) -> str {
    if toint(a) == 0 return "1"
    return "0"
}

// ============================================================================
// COMPARISON OPERATIONS - WITH INPUT VALIDATION
// ============================================================================

// Helper: Check if string is valid integer
proc isValidNumber(s: str) -> bool {
    if length(s) == 0 return false
    var i = 0
    if s[0] == "-" i = 1
    while i < length(s) {
        var c = s[i]
        if c < "0" || c > "9" return false
        i = i + 1
    }
    return true
}

proc vmEqual(a: str, b: str) -> str {
    if a == b return "1"
    return "0"
}

proc vmNotEqual(a: str, b: str) -> str {
    if a != b return "1"
    return "0"
}

proc vmLessThan(a: str, b: str) -> str {
    if !isValidNumber(a) || !isValidNumber(b) {
        errorTypeConversion("vmLessThan: invalid operand")
        return "0"
    }
    if toint(a) < toint(b) return "1"
    return "0"
}

proc vmGreaterThan(a: str, b: str) -> str {
    if !isValidNumber(a) || !isValidNumber(b) {
        errorTypeConversion("vmGreaterThan: invalid operand")
        return "0"
    }
    if toint(a) > toint(b) return "1"
    return "0"
}

proc vmLessEqual(a: str, b: str) -> str {
    if !isValidNumber(a) || !isValidNumber(b) {
        errorTypeConversion("vmLessEqual: invalid operand")
        return "0"
    }
    if toint(a) <= toint(b) return "1"
    return "0"
}

proc vmGreaterEqual(a: str, b: str) -> str {
    if !isValidNumber(a) || !isValidNumber(b) {
        errorTypeConversion("vmGreaterEqual: invalid operand")
        return "0"
    }
    if toint(a) >= toint(b) return "1"
    return "0"
}

// ============================================================================
// LOGICAL OPERATIONS - WITH INPUT VALIDATION
// ============================================================================

proc vmLogicalAnd(a: str, b: str) -> str {
    if !isValidNumber(a) || !isValidNumber(b) {
        errorTypeConversion("vmLogicalAnd: invalid operand")
        return "0"
    }
    if toint(a) != 0 && toint(b) != 0 return "1"
    return "0"
}

proc vmLogicalOr(a: str, b: str) -> str {
    if !isValidNumber(a) || !isValidNumber(b) {
        errorTypeConversion("vmLogicalOr: invalid operand")
        return "0"
    }
    if toint(a) != 0 || toint(b) != 0 return "1"
    return "0"
}

// ============================================================================
// MAIN EXECUTION LOOP - WITH COMPREHENSIVE ERROR HANDLING
// ============================================================================

// Execute all bytecode until halt (CRITICAL FIXES)
proc vmExecute() -> bool {
    initErrorHandling()
    
    while !vm_halted {
        if !vmExecuteInstruction() {
            break
        }
        
        // Check for critical errors
        if hasError() && last_error_level >= ERR_LEVEL_CRITICAL {
            print("CRITICAL ERROR - HALTING VM")
            vm_halted = true
            return false
        }
    }
    
    return true
}

// Execute single instruction with bounds checking (CRITICAL FIXES)
proc vmExecuteInstruction() -> bool {
    // Validate PC (CRITICAL FIX)
    if vm_pc < 0 || vm_pc >= vm_code_len {
        errorInvalidJumpTarget(vm_pc, vm_code_len)
        return false
    }
    
    var opcode = bytecode[vm_pc]
    vm_pc = vm_pc + 1
    
    // ========== OPCODE DISPATCH WITH ERROR HANDLING ==========
    
    if opcode == OP_HALT {
        vm_halted = true
        return false
    }
    
    // LOAD_CONST with bounds checking (CRITICAL FIX)
    if opcode == OP_LOAD_CONST {
        if vm_pc >= vm_code_len {
            errorInvalidJumpTarget(vm_pc, vm_code_len)
            return false
        }
        
        var const_idx = bytecode[vm_pc]
        vm_pc = vm_pc + 1
        
        if const_idx < 0 || const_idx >= vm_constants_len {
            errorBytecodeIndex(const_idx, vm_constants_len)
            vmPush("0")  // Recovery: push 0
            return true
        }
        
        vmPush(bytecode_constants[const_idx])
        return true
    }
    
    // LOAD_VAR with bounds checking (CRITICAL FIX)
    if opcode == OP_LOAD_VAR {
        if vm_pc >= vm_code_len {
            errorInvalidJumpTarget(vm_pc, vm_code_len)
            return false
        }
        
        var var_idx = bytecode[vm_pc]
        vm_pc = vm_pc + 1
        
        if var_idx < 0 {
            errorBytecodeIndex(var_idx, vm_max_locals)
            vmPush("0")
            return true
        }
        
        vmPush(vmGetLocal(var_idx))
        return true
    }
    
    // STORE_VAR with bounds checking (CRITICAL FIX)
    if opcode == OP_STORE_VAR {
        if vm_pc >= vm_code_len {
            errorInvalidJumpTarget(vm_pc, vm_code_len)
            return false
        }
        
        var var_idx = bytecode[vm_pc]
        vm_pc = vm_pc + 1
        
        if var_idx < 0 {
            errorBytecodeIndex(var_idx, vm_max_locals)
            vmPop()  // Discard value
            return true
        }
        
        vmSetLocal(var_idx, vmPop())
        return true
    }
    
    // ========== ARITHMETIC OPERATIONS (INLINED) ==========
    
    if opcode == OP_ADD {
        var b = vmPop()
        var a = vmPop()
        vmPush(vmAdd(a, b))
        return true
    }
    
    if opcode == OP_SUB {
        var b = vmPop()
        var a = vmPop()
        vmPush(vmSubtract(a, b))
        return true
    }
    
    if opcode == OP_MUL {
        var b = vmPop()
        var a = vmPop()
        vmPush(vmMultiply(a, b))
        return true
    }
    
    if opcode == OP_DIV {
        var b = vmPop()
        var a = vmPop()
        vmPush(vmDivide(a, b))
        return true
    }
    
    if opcode == OP_MOD {
        var b = vmPop()
        var a = vmPop()
        vmPush(vmModulo(a, b))
        return true
    }
    
    if opcode == OP_NEG {
        var a = vmPop()
        vmPush(vmNegate(a))
        return true
    }
    
    if opcode == OP_NOT {
        var a = vmPop()
        vmPush(vmLogicalNot(a))
        return true
    }
    
    // ========== COMPARISON OPERATIONS ==========
    
    if opcode == OP_EQ {
        var b = vmPop()
        var a = vmPop()
        vmPush(vmEqual(a, b))
        return true
    }
    
    if opcode == OP_NE {
        var b = vmPop()
        var a = vmPop()
        vmPush(vmNotEqual(a, b))
        return true
    }
    
    if opcode == OP_LT {
        var b = vmPop()
        var a = vmPop()
        vmPush(vmLessThan(a, b))
        return true
    }
    
    if opcode == OP_GT {
        var b = vmPop()
        var a = vmPop()
        vmPush(vmGreaterThan(a, b))
        return true
    }
    
    if opcode == OP_LE {
        var b = vmPop()
        var a = vmPop()
        vmPush(vmLessEqual(a, b))
        return true
    }
    
    if opcode == OP_GE {
        var b = vmPop()
        var a = vmPop()
        vmPush(vmGreaterEqual(a, b))
        return true
    }
    
    // ========== LOGICAL OPERATIONS ==========
    
    if opcode == OP_AND {
        var b = vmPop()
        var a = vmPop()
        vmPush(vmLogicalAnd(a, b))
        return true
    }
    
    if opcode == OP_OR {
        var b = vmPop()
        var a = vmPop()
        vmPush(vmLogicalOr(a, b))
        return true
    }
    
    // ========== CONTROL FLOW WITH VALIDATION ==========
    
    // JMP with bounds checking (CRITICAL FIX)
    if opcode == OP_JMP {
        if vm_pc >= vm_code_len {
            errorInvalidJumpTarget(vm_pc, vm_code_len)
            return false
        }
        
        var target = bytecode[vm_pc]
        
        if target < 0 || target >= vm_code_len {
            errorInvalidJumpTarget(target, vm_code_len)
            return false
        }
        
        vm_pc = target
        return true
    }
    
    // JMP_IF_FALSE with bounds checking (CRITICAL FIX)
    if opcode == OP_JMP_IF_FALSE {
        if vm_pc >= vm_code_len {
            errorInvalidJumpTarget(vm_pc, vm_code_len)
            return false
        }
        
        var target = bytecode[vm_pc]
        vm_pc = vm_pc + 1
        
        if target < 0 || target >= vm_code_len {
            errorInvalidJumpTarget(target, vm_code_len)
            return false
        }
        
        var condition = vmPop()
        
        if toint(condition) == 0 {
            vm_pc = target
        }
        
        return true
    }
    
    // ========== I/O OPERATIONS ==========
    
    if opcode == OP_PRINT {
        print(vmPop())
        return true
    }
    
    if opcode == OP_POP {
        vmPop()
        return true
    }
    
    if opcode == OP_RET {
        vm_return_value = vmPop()
        vm_halted = true
        return false
    }
    
    // Unknown opcode
    setErrorQuick(ERR_VM_INVALID_OPCODE,
                 "Unknown opcode: " + tostring(opcode))
    return false
}

// ============================================================================
// DIAGNOSTICS AND DEBUGGING
// ============================================================================

// Dump VM state for debugging
proc vmDumpState() {
    print("=== VM STATE ===")
    print("PC: " + tostring(vm_pc) + ", SP: " + tostring(vm_sp))
    print("Stack Size: " + tostring(length(vm_stack)))
    print("Locals: " + tostring(length(vm_local_vars)))
    print("Halted: " + tostring(vm_halted))
    print("Return Value: " + vm_return_value)
    
    if hasError() {
        print("ERROR: " + getErrorDescription())
    }
}

// Dump stack contents
proc vmDumpStack() {
    print("=== VM STACK (top " + tostring(vm_sp) + " entries) ===")
    var i = vm_sp - 1
    while i >= 0 && i < length(vm_stack) {
        print("[" + tostring(i) + "] " + vm_stack[i])
        i = i - 1
    }
}

// Dump locals
proc vmDumpLocals() {
    print("=== LOCAL VARIABLES ===")
    var i = 0
    while i < length(vm_local_vars) {
        print("[$" + tostring(i) + "] = " + vm_local_vars[i])
        i = i + 1
    }
}

// Validate VM state
proc vmValidate() -> bool {
    if vm_sp < 0 {
        setErrorQuick(ERR_VM_STACK_UNDERFLOW, "VM stack pointer is negative")
        return false
    }
    
    if vm_sp > vm_max_stack_depth {
        setErrorQuick(ERR_VM_STACK_OVERFLOW, "VM stack pointer exceeds max depth")
        return false
    }
    
    if vm_pc < 0 {
        setErrorQuick(ERR_VM_INVALID_PC, "VM program counter is negative")
        return false
    }
    
    return true
}
